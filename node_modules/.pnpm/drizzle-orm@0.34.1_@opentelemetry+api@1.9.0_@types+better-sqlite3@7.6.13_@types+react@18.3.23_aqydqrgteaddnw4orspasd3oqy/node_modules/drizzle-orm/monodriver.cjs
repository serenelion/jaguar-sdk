"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var monodriver_exports = {};
__export(monodriver_exports, {
  drizzle: () => drizzle
});
module.exports = __toCommonJS(monodriver_exports);
const importError = (libName) => {
  throw new Error(
    `Please install '${libName}' to allow Drizzle ORM to connect to the database`
  );
};
function assertUnreachable(_) {
  throw new Error("Didn't expect to get here");
}
async function drizzle(client, ...params) {
  switch (client) {
    case "node-postgres": {
      const defpg = await import("pg").catch(() => importError("pg"));
      const { drizzle: drizzle2 } = await import("./node-postgres/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = typeof connection === "string" ? new defpg.default.Pool({
          connectionString: connection
        }) : new defpg.default.Pool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = typeof params[0] === "string" ? new defpg.default.Pool({
        connectionString: params[0]
      }) : new defpg.default.Pool(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "aws-data-api-pg": {
      const { connection, ...drizzleConfig } = params[0];
      const { resourceArn, database, secretArn, ...rdsConfig } = connection;
      const { RDSDataClient } = await import("@aws-sdk/client-rds-data").catch(
        () => importError("@aws-sdk/client-rds-data")
      );
      const { drizzle: drizzle2 } = await import("./aws-data-api/pg/index.cjs");
      const instance = new RDSDataClient(rdsConfig);
      const db = drizzle2(instance, { resourceArn, database, secretArn, ...drizzleConfig });
      return db;
    }
    case "better-sqlite3": {
      const { default: Client } = await import("better-sqlite3").catch(() => importError("better-sqlite3"));
      const { drizzle: drizzle2 } = await import("./better-sqlite3/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { source, ...options } = connection;
          const instance3 = new Client(source, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new Client(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "bun:sqlite": {
      const { Database: Client } = await import("bun:sqlite").catch(() => {
        throw new Error(`Please use bun to use 'bun:sqlite' for Drizzle ORM to connect to database`);
      });
      const { drizzle: drizzle2 } = await import("./bun-sqlite/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { source, ...opts } = connection;
          const options = Object.values(opts).filter((v) => v !== void 0).length ? opts : void 0;
          const instance3 = new Client(source, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new Client(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "d1": {
      const { connection, ...drizzleConfig } = params[0];
      const { drizzle: drizzle2 } = await import("./d1/index.cjs");
      const db = drizzle2(connection, drizzleConfig);
      return db;
    }
    case "libsql":
    case "turso": {
      const { createClient } = await import("@libsql/client").catch(() => importError("@libsql/client"));
      const { drizzle: drizzle2 } = await import("./libsql/index.cjs");
      if (typeof params[0] === "string") {
        const instance2 = createClient({
          url: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      const { connection, ...drizzleConfig } = params[0];
      const instance = typeof connection === "string" ? createClient({ url: connection }) : createClient(connection);
      const db = drizzle2(instance, drizzleConfig);
      return db;
    }
    case "mysql2": {
      const { createPool } = await import("mysql2/promise").catch(() => importError("mysql2"));
      const { drizzle: drizzle2 } = await import("./mysql2/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = createPool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const connectionString = params[0];
      const instance = createPool(connectionString);
      const db = drizzle2(instance);
      return db;
    }
    case "neon-http": {
      const { neon } = await import("@neondatabase/serverless").catch(() => importError("@neondatabase/serverless"));
      const { drizzle: drizzle2 } = await import("./neon-http/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { connectionString, ...options } = connection;
          const instance3 = neon(connectionString, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = neon(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = neon(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "neon-websocket": {
      const { Pool, neonConfig } = await import("@neondatabase/serverless").catch(
        () => importError("@neondatabase/serverless")
      );
      const { drizzle: drizzle2 } = await import("./neon-serverless/index.cjs");
      if (typeof params[0] === "string") {
        const instance2 = new Pool({
          connectionString: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      if (typeof params[0] === "object") {
        const { connection, ws, ...drizzleConfig } = params[0];
        if (ws) {
          neonConfig.webSocketConstructor = ws;
        }
        const instance2 = typeof connection === "string" ? new Pool({
          connectionString: connection
        }) : new Pool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Pool();
      const db = drizzle2(instance);
      return db;
    }
    case "planetscale": {
      const { Client } = await import("@planetscale/database").catch(() => importError("@planetscale/database"));
      const { drizzle: drizzle2 } = await import("./planetscale-serverless/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = typeof connection === "string" ? new Client({
          url: connection
        }) : new Client(
          connection
        );
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client({
        url: params[0]
      });
      const db = drizzle2(instance);
      return db;
    }
    case "postgres-js": {
      const { default: client2 } = await import("postgres").catch(() => importError("postgres"));
      const { drizzle: drizzle2 } = await import("./postgres-js/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object" && connection.url !== void 0) {
          const { url, ...config } = connection;
          const instance3 = client2(url, config);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = client2(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = client2(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "tidb-serverless": {
      const { connect } = await import("@tidbcloud/serverless").catch(() => importError("@tidbcloud/serverless"));
      const { drizzle: drizzle2 } = await import("./tidb-serverless/index.cjs");
      if (typeof params[0] === "string") {
        const instance2 = connect({
          url: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      const { connection, ...drizzleConfig } = params[0];
      const instance = typeof connection === "string" ? connect({
        url: connection
      }) : connect(connection);
      const db = drizzle2(instance, drizzleConfig);
      return db;
    }
    case "vercel-postgres": {
      const drizzleConfig = params[0];
      const { sql } = await import("@vercel/postgres").catch(() => importError("@vercel/postgres"));
      const { drizzle: drizzle2 } = await import("./vercel-postgres/index.cjs");
      const db = drizzle2(sql, drizzleConfig);
      return db;
    }
    case "pglite": {
      const { PGlite } = await import("@electric-sql/pglite").catch(() => importError("@electric-sql/pglite"));
      const { drizzle: drizzle2 } = await import("./pglite/index.cjs");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { dataDir, ...options } = connection;
          const instance3 = new PGlite(dataDir, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new PGlite(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new PGlite(params[0]);
      const db = drizzle2(instance);
      return db;
    }
  }
  assertUnreachable(client);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  drizzle
});
//# sourceMappingURL=monodriver.cjs.map