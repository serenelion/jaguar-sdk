const importError = (libName) => {
  throw new Error(
    `Please install '${libName}' to allow Drizzle ORM to connect to the database`
  );
};
function assertUnreachable(_) {
  throw new Error("Didn't expect to get here");
}
async function drizzle(client, ...params) {
  switch (client) {
    case "node-postgres": {
      const defpg = await import("pg").catch(() => importError("pg"));
      const { drizzle: drizzle2 } = await import("./node-postgres/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = typeof connection === "string" ? new defpg.default.Pool({
          connectionString: connection
        }) : new defpg.default.Pool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = typeof params[0] === "string" ? new defpg.default.Pool({
        connectionString: params[0]
      }) : new defpg.default.Pool(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "aws-data-api-pg": {
      const { connection, ...drizzleConfig } = params[0];
      const { resourceArn, database, secretArn, ...rdsConfig } = connection;
      const { RDSDataClient } = await import("@aws-sdk/client-rds-data").catch(
        () => importError("@aws-sdk/client-rds-data")
      );
      const { drizzle: drizzle2 } = await import("./aws-data-api/pg/index.js");
      const instance = new RDSDataClient(rdsConfig);
      const db = drizzle2(instance, { resourceArn, database, secretArn, ...drizzleConfig });
      return db;
    }
    case "better-sqlite3": {
      const { default: Client } = await import("better-sqlite3").catch(() => importError("better-sqlite3"));
      const { drizzle: drizzle2 } = await import("./better-sqlite3/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { source, ...options } = connection;
          const instance3 = new Client(source, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new Client(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "bun:sqlite": {
      const { Database: Client } = await import("bun:sqlite").catch(() => {
        throw new Error(`Please use bun to use 'bun:sqlite' for Drizzle ORM to connect to database`);
      });
      const { drizzle: drizzle2 } = await import("./bun-sqlite/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { source, ...opts } = connection;
          const options = Object.values(opts).filter((v) => v !== void 0).length ? opts : void 0;
          const instance3 = new Client(source, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new Client(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "d1": {
      const { connection, ...drizzleConfig } = params[0];
      const { drizzle: drizzle2 } = await import("./d1/index.js");
      const db = drizzle2(connection, drizzleConfig);
      return db;
    }
    case "libsql":
    case "turso": {
      const { createClient } = await import("@libsql/client").catch(() => importError("@libsql/client"));
      const { drizzle: drizzle2 } = await import("./libsql/index.js");
      if (typeof params[0] === "string") {
        const instance2 = createClient({
          url: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      const { connection, ...drizzleConfig } = params[0];
      const instance = typeof connection === "string" ? createClient({ url: connection }) : createClient(connection);
      const db = drizzle2(instance, drizzleConfig);
      return db;
    }
    case "mysql2": {
      const { createPool } = await import("mysql2/promise").catch(() => importError("mysql2"));
      const { drizzle: drizzle2 } = await import("./mysql2/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = createPool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const connectionString = params[0];
      const instance = createPool(connectionString);
      const db = drizzle2(instance);
      return db;
    }
    case "neon-http": {
      const { neon } = await import("@neondatabase/serverless").catch(() => importError("@neondatabase/serverless"));
      const { drizzle: drizzle2 } = await import("./neon-http/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { connectionString, ...options } = connection;
          const instance3 = neon(connectionString, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = neon(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = neon(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "neon-websocket": {
      const { Pool, neonConfig } = await import("@neondatabase/serverless").catch(
        () => importError("@neondatabase/serverless")
      );
      const { drizzle: drizzle2 } = await import("./neon-serverless/index.js");
      if (typeof params[0] === "string") {
        const instance2 = new Pool({
          connectionString: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      if (typeof params[0] === "object") {
        const { connection, ws, ...drizzleConfig } = params[0];
        if (ws) {
          neonConfig.webSocketConstructor = ws;
        }
        const instance2 = typeof connection === "string" ? new Pool({
          connectionString: connection
        }) : new Pool(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Pool();
      const db = drizzle2(instance);
      return db;
    }
    case "planetscale": {
      const { Client } = await import("@planetscale/database").catch(() => importError("@planetscale/database"));
      const { drizzle: drizzle2 } = await import("./planetscale-serverless/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        const instance2 = typeof connection === "string" ? new Client({
          url: connection
        }) : new Client(
          connection
        );
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new Client({
        url: params[0]
      });
      const db = drizzle2(instance);
      return db;
    }
    case "postgres-js": {
      const { default: client2 } = await import("postgres").catch(() => importError("postgres"));
      const { drizzle: drizzle2 } = await import("./postgres-js/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object" && connection.url !== void 0) {
          const { url, ...config } = connection;
          const instance3 = client2(url, config);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = client2(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = client2(params[0]);
      const db = drizzle2(instance);
      return db;
    }
    case "tidb-serverless": {
      const { connect } = await import("@tidbcloud/serverless").catch(() => importError("@tidbcloud/serverless"));
      const { drizzle: drizzle2 } = await import("./tidb-serverless/index.js");
      if (typeof params[0] === "string") {
        const instance2 = connect({
          url: params[0]
        });
        const db2 = drizzle2(instance2);
        return db2;
      }
      const { connection, ...drizzleConfig } = params[0];
      const instance = typeof connection === "string" ? connect({
        url: connection
      }) : connect(connection);
      const db = drizzle2(instance, drizzleConfig);
      return db;
    }
    case "vercel-postgres": {
      const drizzleConfig = params[0];
      const { sql } = await import("@vercel/postgres").catch(() => importError("@vercel/postgres"));
      const { drizzle: drizzle2 } = await import("./vercel-postgres/index.js");
      const db = drizzle2(sql, drizzleConfig);
      return db;
    }
    case "pglite": {
      const { PGlite } = await import("@electric-sql/pglite").catch(() => importError("@electric-sql/pglite"));
      const { drizzle: drizzle2 } = await import("./pglite/index.js");
      if (typeof params[0] === "object") {
        const { connection, ...drizzleConfig } = params[0];
        if (typeof connection === "object") {
          const { dataDir, ...options } = connection;
          const instance3 = new PGlite(dataDir, options);
          const db3 = drizzle2(instance3, drizzleConfig);
          return db3;
        }
        const instance2 = new PGlite(connection);
        const db2 = drizzle2(instance2, drizzleConfig);
        return db2;
      }
      const instance = new PGlite(params[0]);
      const db = drizzle2(instance);
      return db;
    }
  }
  assertUnreachable(client);
}
export {
  drizzle
};
//# sourceMappingURL=monodriver.js.map