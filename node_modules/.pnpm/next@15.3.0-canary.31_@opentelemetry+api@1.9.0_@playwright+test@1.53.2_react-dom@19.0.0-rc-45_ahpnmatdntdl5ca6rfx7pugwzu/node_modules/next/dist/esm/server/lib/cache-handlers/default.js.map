{"version":3,"sources":["../../../../src/server/lib/cache-handlers/default.ts"],"sourcesContent":["/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandlerV2 } from './types'\nimport {\n  isStale,\n  tagsManifest,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\n// LRU cache default to max 50 MB but in future track\nconst memoryCache = new LRUCache<PrivateCacheEntry>(\n  50 * 1024 * 1024,\n  (entry) => entry.size\n)\nconst pendingSets = new Map<string, Promise<void>>()\n\nconst DefaultCacheHandler: CacheHandlerV2 = {\n  async get(cacheKey) {\n    await pendingSets.get(cacheKey)\n\n    const privateEntry = memoryCache.get(cacheKey)\n\n    if (!privateEntry) {\n      return undefined\n    }\n\n    const entry = privateEntry.entry\n    if (\n      performance.timeOrigin + performance.now() >\n      entry.timestamp + entry.revalidate * 1000\n    ) {\n      // In-memory caches should expire after revalidate time because it is\n      // unlikely that a new entry will be able to be used before it is dropped\n      // from the cache.\n      return undefined\n    }\n\n    if (isStale(entry.tags, entry.timestamp)) {\n      return undefined\n    }\n    const [returnStream, newSaved] = entry.value.tee()\n    entry.value = newSaved\n\n    return {\n      ...entry,\n      value: returnStream,\n    }\n  },\n\n  async set(cacheKey, pendingEntry) {\n    let resolvePending: () => void = () => {}\n    const pendingPromise = new Promise<void>((resolve) => {\n      resolvePending = resolve\n    })\n    pendingSets.set(cacheKey, pendingPromise)\n\n    const entry = await pendingEntry\n\n    let size = 0\n\n    try {\n      const [value, clonedValue] = entry.value.tee()\n      entry.value = value\n      const reader = clonedValue.getReader()\n\n      for (let chunk; !(chunk = await reader.read()).done; ) {\n        size += Buffer.from(chunk.value).byteLength\n      }\n\n      memoryCache.set(cacheKey, {\n        entry,\n        isErrored: false,\n        errorRetryCount: 0,\n        size,\n      })\n    } catch {\n      // TODO: store partial buffer with error after we retry 3 times\n    } finally {\n      resolvePending()\n      pendingSets.delete(cacheKey)\n    }\n  },\n\n  async refreshTags() {\n    // Nothing to do for an in-memory cache handler.\n  },\n\n  async getExpiration(...tags) {\n    return Math.max(...tags.map((tag) => tagsManifest.get(tag) ?? 0))\n  },\n\n  async expireTags(...tags) {\n    const timestamp = Math.round(performance.timeOrigin + performance.now())\n\n    for (const tag of tags) {\n      // TODO: update file-system-cache?\n      tagsManifest.set(tag, timestamp)\n    }\n  },\n}\n\nexport default DefaultCacheHandler\n"],"names":["LRUCache","isStale","tagsManifest","memoryCache","entry","size","pendingSets","Map","DefaultCacheHandler","get","cacheKey","privateEntry","undefined","performance","timeOrigin","now","timestamp","revalidate","tags","returnStream","newSaved","value","tee","set","pendingEntry","resolvePending","pendingPromise","Promise","resolve","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","delete","refreshTags","getExpiration","Math","max","map","tag","expireTags","round"],"mappings":"AAAA;;;;;;;CAOC,GAED,SAASA,QAAQ,QAAQ,eAAc;AAEvC,SACEC,OAAO,EACPC,YAAY,QACP,8CAA6C;AAsBpD,qDAAqD;AACrD,MAAMC,cAAc,IAAIH,SACtB,KAAK,OAAO,MACZ,CAACI,QAAUA,MAAMC,IAAI;AAEvB,MAAMC,cAAc,IAAIC;AAExB,MAAMC,sBAAsC;IAC1C,MAAMC,KAAIC,QAAQ;QAChB,MAAMJ,YAAYG,GAAG,CAACC;QAEtB,MAAMC,eAAeR,YAAYM,GAAG,CAACC;QAErC,IAAI,CAACC,cAAc;YACjB,OAAOC;QACT;QAEA,MAAMR,QAAQO,aAAaP,KAAK;QAChC,IACES,YAAYC,UAAU,GAAGD,YAAYE,GAAG,KACxCX,MAAMY,SAAS,GAAGZ,MAAMa,UAAU,GAAG,MACrC;YACA,qEAAqE;YACrE,yEAAyE;YACzE,kBAAkB;YAClB,OAAOL;QACT;QAEA,IAAIX,QAAQG,MAAMc,IAAI,EAAEd,MAAMY,SAAS,GAAG;YACxC,OAAOJ;QACT;QACA,MAAM,CAACO,cAAcC,SAAS,GAAGhB,MAAMiB,KAAK,CAACC,GAAG;QAChDlB,MAAMiB,KAAK,GAAGD;QAEd,OAAO;YACL,GAAGhB,KAAK;YACRiB,OAAOF;QACT;IACF;IAEA,MAAMI,KAAIb,QAAQ,EAAEc,YAAY;QAC9B,IAAIC,iBAA6B,KAAO;QACxC,MAAMC,iBAAiB,IAAIC,QAAc,CAACC;YACxCH,iBAAiBG;QACnB;QACAtB,YAAYiB,GAAG,CAACb,UAAUgB;QAE1B,MAAMtB,QAAQ,MAAMoB;QAEpB,IAAInB,OAAO;QAEX,IAAI;YACF,MAAM,CAACgB,OAAOQ,YAAY,GAAGzB,MAAMiB,KAAK,CAACC,GAAG;YAC5ClB,MAAMiB,KAAK,GAAGA;YACd,MAAMS,SAASD,YAAYE,SAAS;YAEpC,IAAK,IAAIC,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMF,OAAOG,IAAI,EAAC,EAAGC,IAAI,EAAI;gBACrD7B,QAAQ8B,OAAOC,IAAI,CAACJ,MAAMX,KAAK,EAAEgB,UAAU;YAC7C;YAEAlC,YAAYoB,GAAG,CAACb,UAAU;gBACxBN;gBACAkC,WAAW;gBACXC,iBAAiB;gBACjBlC;YACF;QACF,EAAE,OAAM;QACN,+DAA+D;QACjE,SAAU;YACRoB;YACAnB,YAAYkC,MAAM,CAAC9B;QACrB;IACF;IAEA,MAAM+B;IACJ,gDAAgD;IAClD;IAEA,MAAMC,eAAc,GAAGxB,IAAI;QACzB,OAAOyB,KAAKC,GAAG,IAAI1B,KAAK2B,GAAG,CAAC,CAACC,MAAQ5C,aAAaO,GAAG,CAACqC,QAAQ;IAChE;IAEA,MAAMC,YAAW,GAAG7B,IAAI;QACtB,MAAMF,YAAY2B,KAAKK,KAAK,CAACnC,YAAYC,UAAU,GAAGD,YAAYE,GAAG;QAErE,KAAK,MAAM+B,OAAO5B,KAAM;YACtB,kCAAkC;YAClChB,aAAaqB,GAAG,CAACuB,KAAK9B;QACxB;IACF;AACF;AAEA,eAAeR,oBAAmB"}