{"version":3,"sources":["../../../src/server/lib/implicit-tags.ts"],"sourcesContent":["import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { getCacheHandlers } from '../use-cache/handlers'\n\nexport interface ImplicitTags {\n  /**\n   * For legacy usage, the implicit tags are passed to the incremental cache\n   * handler in `get` calls.\n   */\n  readonly tags: string[]\n  /**\n   * Modern cache handlers don't receive implicit tags. Instead, the\n   * implicit tags' expiration is stored in the work unit store, and used to\n   * compare with a cache entry's timestamp.\n   */\n  readonly expiration: number\n}\n\nconst getDerivedTags = (pathname: string): string[] => {\n  const derivedTags: string[] = [`/layout`]\n\n  // we automatically add the current path segments as tags\n  // for revalidatePath handling\n  if (pathname.startsWith('/')) {\n    const pathnameParts = pathname.split('/')\n\n    for (let i = 1; i < pathnameParts.length + 1; i++) {\n      let curPathname = pathnameParts.slice(0, i).join('/')\n\n      if (curPathname) {\n        // all derived tags other than the page are layout tags\n        if (!curPathname.endsWith('/page') && !curPathname.endsWith('/route')) {\n          curPathname = `${curPathname}${\n            !curPathname.endsWith('/') ? '/' : ''\n          }layout`\n        }\n        derivedTags.push(curPathname)\n      }\n    }\n  }\n  return derivedTags\n}\n\nasync function getImplicitTagsExpiration(tags: string[]): Promise<number> {\n  // We're starting off with assuming that implicit tags are not expired, so we\n  // use an artificial timestamp of 0.\n  let expiration = 0\n\n  const cacheHandlers = getCacheHandlers()\n\n  if (cacheHandlers) {\n    const expirations = await Promise.all(\n      [...cacheHandlers].map(async (handler) => {\n        if ('getExpiration' in handler) {\n          return handler.getExpiration(...tags)\n        }\n\n        // Use 0 as fallback of legacy cache handlers. We don't need to track\n        // the expiration of implicit tags for those, because they're passed\n        // into the `get()` method and are checked internally by the cache\n        // handler.\n        return 0\n      })\n    )\n\n    // We use the most recent expiration from all cache handlers, i.e. the\n    // largest timestamp. Semantically, they should all be the same though.\n    expiration = Math.max(...expirations)\n  }\n\n  return expiration\n}\n\nexport async function getImplicitTags(\n  page: string,\n  url: {\n    pathname: string\n    search?: string\n  },\n  fallbackRouteParams: null | FallbackRouteParams\n): Promise<ImplicitTags> {\n  // TODO: Cache the result\n  const tags: string[] = []\n  const hasFallbackRouteParams =\n    fallbackRouteParams && fallbackRouteParams.size > 0\n\n  // Add the derived tags from the page.\n  const derivedTags = getDerivedTags(page)\n  for (let tag of derivedTags) {\n    tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`\n    tags.push(tag)\n  }\n\n  // Add the tags from the pathname. If the route has unknown params, we don't\n  // want to add the pathname as a tag, as it will be invalid.\n  if (url.pathname && !hasFallbackRouteParams) {\n    const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`\n    tags.push(tag)\n  }\n\n  const expiration = await getImplicitTagsExpiration(tags)\n\n  return { tags, expiration }\n}\n"],"names":["NEXT_CACHE_IMPLICIT_TAG_ID","getCacheHandlers","getDerivedTags","pathname","derivedTags","startsWith","pathnameParts","split","i","length","curPathname","slice","join","endsWith","push","getImplicitTagsExpiration","tags","expiration","cacheHandlers","expirations","Promise","all","map","handler","getExpiration","Math","max","getImplicitTags","page","url","fallbackRouteParams","hasFallbackRouteParams","size","tag"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,sBAAqB;AAEhE,SAASC,gBAAgB,QAAQ,wBAAuB;AAgBxD,MAAMC,iBAAiB,CAACC;IACtB,MAAMC,cAAwB;QAAC,CAAC,OAAO,CAAC;KAAC;IAEzC,yDAAyD;IACzD,8BAA8B;IAC9B,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,gBAAgBH,SAASI,KAAK,CAAC;QAErC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,cAAcG,MAAM,GAAG,GAAGD,IAAK;YACjD,IAAIE,cAAcJ,cAAcK,KAAK,CAAC,GAAGH,GAAGI,IAAI,CAAC;YAEjD,IAAIF,aAAa;gBACf,uDAAuD;gBACvD,IAAI,CAACA,YAAYG,QAAQ,CAAC,YAAY,CAACH,YAAYG,QAAQ,CAAC,WAAW;oBACrEH,cAAc,GAAGA,cACf,CAACA,YAAYG,QAAQ,CAAC,OAAO,MAAM,GACpC,MAAM,CAAC;gBACV;gBACAT,YAAYU,IAAI,CAACJ;YACnB;QACF;IACF;IACA,OAAON;AACT;AAEA,eAAeW,0BAA0BC,IAAc;IACrD,6EAA6E;IAC7E,oCAAoC;IACpC,IAAIC,aAAa;IAEjB,MAAMC,gBAAgBjB;IAEtB,IAAIiB,eAAe;QACjB,MAAMC,cAAc,MAAMC,QAAQC,GAAG,CACnC;eAAIH;SAAc,CAACI,GAAG,CAAC,OAAOC;YAC5B,IAAI,mBAAmBA,SAAS;gBAC9B,OAAOA,QAAQC,aAAa,IAAIR;YAClC;YAEA,qEAAqE;YACrE,oEAAoE;YACpE,kEAAkE;YAClE,WAAW;YACX,OAAO;QACT;QAGF,sEAAsE;QACtE,uEAAuE;QACvEC,aAAaQ,KAAKC,GAAG,IAAIP;IAC3B;IAEA,OAAOF;AACT;AAEA,OAAO,eAAeU,gBACpBC,IAAY,EACZC,GAGC,EACDC,mBAA+C;IAE/C,yBAAyB;IACzB,MAAMd,OAAiB,EAAE;IACzB,MAAMe,yBACJD,uBAAuBA,oBAAoBE,IAAI,GAAG;IAEpD,sCAAsC;IACtC,MAAM5B,cAAcF,eAAe0B;IACnC,KAAK,IAAIK,OAAO7B,YAAa;QAC3B6B,MAAM,GAAGjC,6BAA6BiC,KAAK;QAC3CjB,KAAKF,IAAI,CAACmB;IACZ;IAEA,4EAA4E;IAC5E,4DAA4D;IAC5D,IAAIJ,IAAI1B,QAAQ,IAAI,CAAC4B,wBAAwB;QAC3C,MAAME,MAAM,GAAGjC,6BAA6B6B,IAAI1B,QAAQ,EAAE;QAC1Da,KAAKF,IAAI,CAACmB;IACZ;IAEA,MAAMhB,aAAa,MAAMF,0BAA0BC;IAEnD,OAAO;QAAEA;QAAMC;IAAW;AAC5B"}