"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImplicitTags", {
    enumerable: true,
    get: function() {
        return getImplicitTags;
    }
});
const _constants = require("../../lib/constants");
const _handlers = require("../use-cache/handlers");
const getDerivedTags = (pathname)=>{
    const derivedTags = [
        `/layout`
    ];
    // we automatically add the current path segments as tags
    // for revalidatePath handling
    if (pathname.startsWith('/')) {
        const pathnameParts = pathname.split('/');
        for(let i = 1; i < pathnameParts.length + 1; i++){
            let curPathname = pathnameParts.slice(0, i).join('/');
            if (curPathname) {
                // all derived tags other than the page are layout tags
                if (!curPathname.endsWith('/page') && !curPathname.endsWith('/route')) {
                    curPathname = `${curPathname}${!curPathname.endsWith('/') ? '/' : ''}layout`;
                }
                derivedTags.push(curPathname);
            }
        }
    }
    return derivedTags;
};
async function getImplicitTagsExpiration(tags) {
    // We're starting off with assuming that implicit tags are not expired, so we
    // use an artificial timestamp of 0.
    let expiration = 0;
    const cacheHandlers = (0, _handlers.getCacheHandlers)();
    if (cacheHandlers) {
        const expirations = await Promise.all([
            ...cacheHandlers
        ].map(async (handler)=>{
            if ('getExpiration' in handler) {
                return handler.getExpiration(...tags);
            }
            // Use 0 as fallback of legacy cache handlers. We don't need to track
            // the expiration of implicit tags for those, because they're passed
            // into the `get()` method and are checked internally by the cache
            // handler.
            return 0;
        }));
        // We use the most recent expiration from all cache handlers, i.e. the
        // largest timestamp. Semantically, they should all be the same though.
        expiration = Math.max(...expirations);
    }
    return expiration;
}
async function getImplicitTags(page, url, fallbackRouteParams) {
    // TODO: Cache the result
    const tags = [];
    const hasFallbackRouteParams = fallbackRouteParams && fallbackRouteParams.size > 0;
    // Add the derived tags from the page.
    const derivedTags = getDerivedTags(page);
    for (let tag of derivedTags){
        tag = `${_constants.NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`;
        tags.push(tag);
    }
    // Add the tags from the pathname. If the route has unknown params, we don't
    // want to add the pathname as a tag, as it will be invalid.
    if (url.pathname && !hasFallbackRouteParams) {
        const tag = `${_constants.NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`;
        tags.push(tag);
    }
    const expiration = await getImplicitTagsExpiration(tags);
    return {
        tags,
        expiration
    };
}

//# sourceMappingURL=implicit-tags.js.map